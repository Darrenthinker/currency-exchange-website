# API 调用次数分析

## 每次 API 调用消耗的配额

根据 UniRateAPI 的计费规则，**每次 API 调用消耗 1 次配额**。

### API 调用点分析

#### 1. 获取币种列表
- **函数**：`getSupportedCurrenciesFromAPI()`
- **调用时机**：页面首次加载时
- **消耗配额**：**1 次**
- **频率**：每天 1 次（页面加载时）

#### 2. 获取实时汇率
- **函数**：`getExchangeRate(fromCurrency, toCurrency)`
- **调用时机**：
  - 用户选择货币对时
  - 用户输入金额时
  - 用户点击"刷新汇率"时
- **消耗配额**：**1 次/每次调用**
- **频率**：取决于用户操作频率

#### 3. 获取历史数据
- **函数**：`generateHistoricalData(fromCurrency, toCurrency, period)`
- **调用时机**：
  - 用户选择时间段时
  - 只在固定时间点（0、4、8、12、16、20点）调用
- **消耗配额**：**1 次/每次调用**
- **频率**：每天最多 6 次（固定时间点）

#### 4. 初始汇率获取
- **函数**：`getExchangeRate('USD', 'CNY')`
- **调用时机**：页面首次加载时
- **消耗配额**：**1 次**
- **频率**：每天 1 次（页面加载时）

## 每日配额使用估算

### 正常使用场景

假设一个用户一天的使用情况：

1. **页面加载**：1 次（获取币种列表）+ 1 次（初始汇率）= **2 次**
2. **用户操作**：
   - 切换货币对 5 次 = **5 次**
   - 输入金额查询 10 次 = **10 次**
   - 查看历史数据 3 次（在固定时间点）= **3 次**
3. **刷新汇率**：2 次 = **2 次**

**总计**：约 **22 次/用户/天**

### 多用户场景

如果有 10 个用户同时使用：
- 10 个用户 × 22 次 = **220 次/天**

**结论**：免费套餐的 200 次/天限制很容易被用完！

## 已实施的优化

### 1. 禁用预加载 ✅
- **节省**：每次切换货币时减少 1 次调用
- **效果**：减少约 50-70% 的 API 调用

### 2. 24小时缓存机制 ✅
- **节省**：相同货币对的重复查询使用缓存
- **效果**：减少重复调用

### 3. 移除加密货币 ✅
- **节省**：币种列表更小，减少不必要的查询
- **效果**：专注于法币兑换，减少混淆

### 4. 固定时间点更新历史数据 ✅
- **节省**：历史数据只在固定时间点更新
- **效果**：每天最多 6 次历史数据调用

## 进一步优化建议

### 1. 使用本地币种列表（不调用API）
- **当前**：每次页面加载都调用 `getSupportedCurrenciesFromAPI()`
- **优化**：使用本地币种列表，不调用 API
- **节省**：每天 1 次调用

### 2. 延迟加载初始汇率
- **当前**：页面加载时立即获取初始汇率
- **优化**：只在用户实际需要时才获取
- **节省**：每天 1 次调用

### 3. 批量获取主要货币对
- **当前**：每次只获取一个货币对
- **优化**：一次获取多个常用货币对（如果API支持）
- **节省**：减少调用次数

## 优化后的配额使用估算

### 单用户场景（优化后）

1. **页面加载**：0 次（使用本地币种列表）
2. **用户操作**：
   - 切换货币对 5 次 = **5 次**（使用缓存后可能更少）
   - 输入金额查询 10 次 = **0-2 次**（大部分使用缓存）
   - 查看历史数据 3 次 = **3 次**（固定时间点）
3. **刷新汇率**：2 次 = **2 次**

**总计**：约 **10-12 次/用户/天**

### 多用户场景（优化后）

如果有 10 个用户：
- 10 个用户 × 12 次 = **120 次/天**

**结论**：优化后可以支持更多用户！

## 当前配额使用情况

根据控制台错误信息：
- **限制**：200 次/天
- **已用**：200 次（已用完）
- **重置时间**：每天 UTC 0 点（北京时间 8 点）

## 建议

1. **立即实施**：使用本地币种列表，不调用 API
2. **监控使用**：添加 API 调用计数器
3. **缓存优化**：确保缓存机制正常工作
4. **用户提示**：接近限制时提前提示用户

